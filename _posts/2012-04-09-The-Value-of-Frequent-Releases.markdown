---
layout: post
title: "If It&#8217;s Not on Prod, It Doesn&#8217;t Count: The Value of Frequent Releases"
---
<p>At Shutterstock, we like to release code.  A lot.  We do it about 60 times per week.</p>
<p>Frequent code releases have become somewhat of a mantra among today&#8217;s fast-moving startups, but the value they bring isn&#8217;t always articulated well.  In fact, there are a lot of reasons <em>not</em> to push frequently: you could release shoddy or incomplete software, it might not be thoroughly tested, or you might not like the constant pressure of production deployments.</p>
<p>So it&#8217;s worth stepping back to look at all the benefits that frequent releases bring:</p>
<p><strong>1) You deliver value to customers more quickly.</strong></p>
<p>This is the first principle of the agile manifesto: &#8220;Our highest priority is to satisfy the customer through early and continuous delivery of valuable software.&#8221;  Features that are sitting in your development environment aren&#8217;t benefiting your customers.  Frequent releases get those features into the wild so that your customers can use them.</p>
<p>Be sure to relentlessly focus on <em>delivering value to customers</em>.  Too often, frequent releases are interpreted as breaking big, complicated projects into component parts: first you tackle database schema changes, then business logic, then graphic design.  That&#8217;s not the point.  The point is to deliver complete, valuable features to customers as quickly as possible.</p>
<p>This idea also isn&#8217;t about releasing half-baked or hacky code.  The art is in finding the smallest implementation the team can develop, test, and release within a short period of time.   It helps to ask yourself, &#8220;what is the smallest impactful change we can make to get to our goal?&#8221;  Then, challenge what you decided was &#8220;smallest&#8221; &#8212; can you really not get there with an even smaller implementation?  In the end, you want to do the minimal work to test your idea with customers, then learn and repeat.</p>
<p><strong>2) You learn quickly.</strong></p>
<p>The lean software movement has popularized a revolutionary business philosophy: W<em>e don&#8217;t know what the best thing to do is</em>.  The only way we <em>can</em> know it is to put something in front of customers and get their reactions to it.</p>
<p>By releasing software frequently, you have many more opportunities to get customer feedback and pivot based on it.  You avoid going too far down a path that&#8217;s not valuable.</p>
<p><strong>3) It forces you to break big ideas into manageable pieces.</strong></p>
<p>Big projects are risky, complex, and interminable.  By breaking big projects into small pieces and releasing one piece at a time, we not only deliver value more quickly, but we avoid death marches that demoralize software teams.</p>
<p>This is far easier said than done, because everyone loves big, splashy projects &#8212; they generate attention, they get people excited, and they offer a fleeting sense of accomplishment.  But users rarely like big, splashy projects.  In fact, users generally don&#8217;t like any sort of change; it forces them to re-learn something that they don&#8217;t want to re-learn.  By delivering small pieces of functionality, you provide additional value to users without surprising them with radical change.</p>
<p>Some people will object that an incremental process ultimately takes longer than a monolithic one.  That&#8217;s okay &#8212; it&#8217;s a trade-off we&#8217;re very happy to make, for two reasons: first, although the final result may end up in customers&#8217; hands later, we&#8217;ve been delivering small pieces of value the whole time.  Second, it lets us change direction along the way as we learn instead of committing to a big project that we&#8217;re not sure has value.</p>
<p><strong>4) You avoid horrible merges.</strong></p>
<p>Merging code has always been and always will be a pain in the ass.  The more we can avoid it, the happier and more productive we&#8217;ll all be.  Frequent releases mean that code merges are small and simple (if they&#8217;re necessary at all).  This means you can move more quickly, and developers stay happier.</p>
<p><strong>5) With good automated testing and an a/b testing platform, you reduce risk.</strong></p>
<p>One complication of releasing frequently is making sure that your software works well and is thoroughly tested.  That&#8217;s why automated tests are so important in an agile environment &#8212; they let you quickly and thoroughly ensure that your code works.  Shorter release cycles inherently produce smaller code pushes.  In general, smaller code pushes are less risky simply because fewer things can go wrong.  By coupling small code pushes with automated testing, you can move quickly with little risk.</p>
<p>A good a/b testing platform also lets you iterate rapidly with low risk.  If you&#8217;re able to test changes on 1% of your customers, you drastically reduce the risk associated with rolling out new features, and are able to learn and adapt more quickly.</p>
<p><strong>6) You reduce complexity.</strong></p>
<p>Lots of developers like to over-engineer.  Given enough time, we&#8217;ll build dozens of layers of unnecessary abstraction (see <a href="http://en.wikipedia.org/wiki/Parkinson's_law" target="_blank">Parkison&#8217;s Law</a>).  By requiring frequent releases, we push ourselves to choose the simplest path forward.</p>
<p>If not done well, it <em>is</em> possible to paint yourself into a corner with this approach.  It&#8217;s important to remember that frequent releases don&#8217;t mean short-sighted thinking.  You can still get to a distant goal by approaching it one step at a time.</p>
<p><strong>7) It keeps people motivated.</strong></p>
<p>Who wants to work on a project for months (or <em>years</em>) and never have the thrill of showing it off to their friends?  Or hearing what customers think of it?  Frequent releases motivate people by letting them see the results of their hard work.</p>
<p>We use the scrum/agile framework, with two-week sprints and a demo at the end of each iteration.  A few years ago we started enforcing a rule to drive this point home: you can only demo what&#8217;s on production.  <em>If it&#8217;s not on prod, it doesn&#8217;t count.</em> That&#8217;s our way of saying, &#8220;You can code all you want, but all that matters is what our customers can do with it.&#8221;</p>
<p>For all these reasons, we evangelize frequent releases.  That&#8217;s not meant to minimize their difficulty.  It&#8217;s often very challenging to figure out how to take a small step forward that delivers value to customers while working towards a more distant goal and letting you change direction if necessary.  We never said it was easy.  In fact, it&#8217;s probably one of the most difficult problems in modern software development, because it requires developers to not only be great architects but also appreciate customer needs and product development.  But it&#8217;s the best method we&#8217;ve found for moving our business forward quickly while minimizing risk.</p>
